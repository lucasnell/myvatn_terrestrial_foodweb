% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa-class.R
\docType{class}
\name{web}
\alias{web}
\title{Foodweb class that implements either of the two versions of the model (A and B).}
\format{An \code{\link{R6Class}} generator object}
\usage{
\preformatted{w <- web$new(...)

w$eq_solve(solve_pars = c("mP", "mD", "aNP", "aDV", "aPH", "aR"),
           initial_vals = rep(0.1, 6))
w$values()
w$ode_solve(tmax, a, b, r, w, d, tstep = 1)
w$test_midges(tmax, a, b, r, w, d, tstep = 1)
print(w)
}
}
\arguments{
\item{...}{Custom settings for any of the slots. See below for possible arguments.}

\item{solve_pars}{A character vector of length 6 of the parameters that need to be
solved for. Defaults to \code{c("mP", "mD", "aNP", "aDV", "aPH", "aR")}.}

\item{initial_vals}{Numeric vector of length 6 representing the initial guesses of
the unknown parameters. For more info, see \code{\link[rootSolve]{multiroot}}.}

\item{tmax}{Duration over which to run the model.}

\item{a}{Controls the smoothness of the pulse, along with \code{r}. If \code{a} is
sufficiently high, the pulse will always be rectangular (for more info,
see `vignette("smooth_pulse", "mtf")`).}

\item{b}{Maximum value of the midge pulse (for more info, see
`vignette("smooth_pulse", "mtf")`).}

\item{r}{Period of the pulse expresed in units of \code{1.5 * w} (so the pulses
don't overlap). Also controls the smoothness, along with \code{a} (for more
info, see `vignette("smooth_pulse", "mtf")`).}

\item{w}{Width of the midge pulse (for more info, see
`vignette("smooth_pulse", "mtf")`).}

\item{d}{Mid point of the first pulse in units of \code{w} (for more info, see
`vignette("smooth_pulse", "mtf")`).}

\item{tstep}{Step size in units of time. Defaults to \code{1}.}
}
\description{
This class stores all the necessary parameters and methods to solve for unknown
parameters and to solve the ODEs and output a time series of pool nitrogen contents.
}
\details{
\strong{Note:} This class by default does not make a copy of itself.
In the "Examples" section below, under the heading "Issues with not copying by default",
it shows how this could create weird problems and how to get it to create a copy.
Most of the time, it's probably just easiest to re-run the original code if you want
a new \code{web} object.

After creating a \code{web} object, you need to solve for any unknown parameters,
given the 'known' parameters and equilibria (using the \code{$eq_solve()} method).
To output a time series of simulated data, you should use the
\code{$ode_solve()} method that solves the ODEs.
}
\section{Slots}{

\describe{
\item{\code{Neq}}{Desired equilibrium value for N.}

\item{\code{Deq}}{Desired equilibrium value for D.}

\item{\code{Peq}}{Desired equilibrium value for P.}

\item{\code{Veq}}{Desired equilibrium value for V.}

\item{\code{Heq}}{Desired equilibrium value for H.}

\item{\code{Req}}{Desired equilibrium value for R.}

\item{\code{Meq}}{Desired equilibrium value for M.}

\item{\code{N0}}{Initial state for N.}

\item{\code{D0}}{Initial state for D.}

\item{\code{P0}}{Initial state for P.}

\item{\code{V0}}{Initial state for V.}

\item{\code{H0}}{Initial state for H.}

\item{\code{R0}}{Initial state for R.}

\item{\code{M0}}{Initial state for M.}

\item{\code{iN}}{Input to N.}

\item{\code{lD}}{Loss rates systems for D.}

\item{\code{lP}}{Loss rates systems for P.}

\item{\code{lV}}{Loss rates systems for V.}

\item{\code{lH}}{Loss rates systems for H.}

\item{\code{lR}}{Loss rates systems for R.}

\item{\code{lM}}{Loss rates systems for M.}

\item{\code{mN}}{Loss rates from pool N (returned to either N or D).}

\item{\code{mP}}{Loss rates from pool P (returned to either N or D).}

\item{\code{mD}}{Loss rates from pool D (returned to either N or D).}

\item{\code{mV}}{Loss rates from pool V (returned to either N or D).}

\item{\code{mH}}{Loss rates from pool H (returned to either N or D).}

\item{\code{mR}}{Loss rates from pool R (returned to either N or D).}

\item{\code{mM}}{Loss rates from pool M (returned to either N or D).}

\item{\code{kP}}{Carrying capacity for P.}

\item{\code{kV}}{Carrying capacity for V. Only used for model A.}

\item{\code{kH}}{Carrying capacity for H. Only used for model A.}

\item{\code{kR}}{Carrying capacity for R. Only used for model A.}

\item{\code{hP}}{Handing time for P. Only for model B.}

\item{\code{hD}}{Handing time for D. Only for model B.}

\item{\code{hR}}{Handing time for R. Only for model B.}

\item{\code{aNP}}{Uptake rate for NP.}

\item{\code{aDV}}{Uptake rate for DV.}

\item{\code{aPH}}{Uptake rate for PH.}

\item{\code{aR}}{Uptake rate for R.}

\item{\code{model}}{Which model to use ("A" or "B").}
}}

\section{Methods}{


\describe{
    \item{\code{$values()}}{
        Return a list of all parameter values.
    }
    \item{\code{$eq_solve(solve_pars, initial_vals)}}{
        Use estimated equilibrium N and selected values for certain
        parameters to solve for unknown values. "Known" parameters must be selected
        with care, to ensure that an equilibrium solution can actually be reached.
    }
    \item{\code{$ode_solve(tmax, a, b, r, w, d, tstep)}}{
        Solve the ODE and output timeseries of nitrogen content for each pool.
    }
    \item{\code{$test_midges(tmax, a, b, r, w, d, tstep)}}{
        Test out a particular midge pulse scenario. It returns a vector of
        inputs of midges (in units of N) to the midge pool through time.
    }
}
}

\section{Slots}{

}

\examples{

# Initialize model (A is default)
foodweb_A = web$new(model="A")

# Solve for unknown values
foodweb_A$eq_solve()

# Viewing class:
foodweb_A

# Outputting all values as a list:
foodweb_A$values()

# Outputting a single value
foodweb_A$D0
# If you wanted to change this, you'd uncomment the next line
# foodweb_A$D0 = 40e3L


# Test midge pulse:
plot(foodweb_A$test_midges(1000, a=1000, b=1, r=1, w=400, d=1), type = 'l',
     ylab = "iM")


# Solve ODEs
output_A = foodweb_A$ode_solve(tmax = 1000, a=1000, b=1, r=1, w=400, d=1)

# Plot absolute N
output_A  \%>\%
    group_by(pool) \%>\%
    # Define 'minb' to set the minimum value for the y-axis.
    # This allows different y-scales for different facets, with the ymin set to 0
    mutate(minb = 0) \%>\%
    ggplot(aes(time, N)) +
    facet_wrap(~pool, scales="free_y") +
    # The horizontal lines show the initial states
    geom_hline(data = foodweb_A$initial_states,
               aes(yintercept=N), color="firebrick") +
    geom_line(size = 1) +
    geom_point(aes(time, minb), shape="") +
    theme_classic()

# Relative to Equilibrium
# Note that this gives weird results when there is no deviation from equilibrium
# This is probably due to small numerical errors, but is not a big issue
output_A \%>\%
    filter(pool!="midge") \%>\%
    group_by(pool) \%>\%
    # Scale the N relative to the initial state
    mutate(N_scale = N/N[1]) \%>\%
    ggplot(aes(time, N_scale)) +
    facet_wrap(~pool) +
    geom_hline(yintercept = 1, color="firebrick4") +
    geom_line(size = 1) +
    theme_classic()




# ----------
# Issues with not copying by default
# ----------

# Why not making copies can be a problem:
foodweb_B = foodweb_A
foodweb_B$model = "B"
foodweb_A$model
foodweb_A$model = "A" # changing back to correct value

# The proper way to make a copy: Use the `$clone()` method
foodweb_B = foodweb_A$clone()
foodweb_B$model = "B"
foodweb_A$model




}
\keyword{data}
